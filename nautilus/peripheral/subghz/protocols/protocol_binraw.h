/**
 * BinRAW Protocol Implementation
 *
 * BinRAW is a compressed pulse sequence format used by Flipper Zero for storing
 * arbitrary RF signals in a space-efficient manner. It's not a protocol per se,
 * but rather a file format that stores pre-recorded signals.
 *
 * Encoding Scheme:
 * - Each bit in Data_RAW represents ONE TE (time element) interval
 * - Bit = 1: Carrier is HIGH for 1 TE
 * - Bit = 0: Carrier is LOW for 1 TE
 * - Consecutive same bits are combined into longer pulses
 *
 * Example:
 *   TE = 100 us
 *   Data_RAW = 0x37 = 0b00110111
 *
 *   Reading left to right:
 *   00110111 -> -200us (2xLOW) +300us (3xHIGH) -100us (1xLOW) +300us (3xHIGH)
 *
 * File Format (Flipper Zero .sub format):
 *   Filetype: Flipper SubGhz Key File
 *   Version: 1
 *   Frequency: 315000000
 *   Preset: FuriHalSubGhzPresetOok650Async
 *   Protocol: BinRAW
 *   Bit: 82                           # Total bits
 *   TE: 201                           # Time element in microseconds
 *   Bit_RAW: 82                       # Bits in this Data_RAW block
 *   Data_RAW: 00 00 00 74 47 47 47 47 74 44 47
 *
 * Multiple Data_RAW blocks are supported for complex signals with gaps.
 *
 * Reference: Flipper Zero/Momentum Firmware implementation
 * Location: lib/subghz/protocols/bin_raw.c
 */

#ifndef __PROTOCOL_BINRAW_H__
#define __PROTOCOL_BINRAW_H__

#include "../protocol_base.h"
#include <vector>

/**
 * Maximum number of Data_RAW blocks per file
 * Matches Flipper Zero: BIN_RAW_MAX_MARKUP_COUNT = 20
 */
#define BINRAW_MAX_BLOCKS 20

/**
 * Maximum data buffer size in bytes
 * Matches Flipper Zero: BIN_RAW_BUF_DATA_SIZE = 512
 */
#define BINRAW_MAX_DATA_SIZE 512

/**
 * Represents one Data_RAW block in the file
 */
struct BinRAW_Block {
    uint16_t bit_count;                      // Number of bits in this block
    uint16_t byte_count;                     // Number of bytes (bit_count / 8, rounded up)
    uint8_t data[BINRAW_MAX_DATA_SIZE];      // Binary data (bit array)
};

class BinRAWProtocol : public SubGhzProtocol {
private:
    // Default TE value (can be overridden from file)
    static const uint32_t BINRAW_TE_DEFAULT = 200;

    // RMT encoded data for transmission
    std::vector<rmt_item32_t> rmt_items;

    // Data blocks loaded from file
    std::vector<BinRAW_Block> blocks;
    uint32_t te;                             // Time element in microseconds
    uint32_t total_bits;                     // Total bits across all blocks

    /**
     * Convert bit array to RMT items for transmission
     * Reads bits sequentially and combines consecutive same bits into pulses
     *
     * @param data Bit array (MSB first within each byte)
     * @param bit_count Number of bits to encode
     * @param te_us Time element in microseconds
     * @param start_level Initial level (true=HIGH, false=LOW)
     * @param items Output: RMT items
     */
    void bitsToRMT(const uint8_t* data, uint16_t bit_count, uint32_t te_us,
                   bool start_level, std::vector<rmt_item32_t>& items);

    /**
     * Get bit value from bit array
     * Bits are numbered from MSB (bit 7) to LSB (bit 0) within each byte
     *
     * @param data Bit array
     * @param index Bit index (0-based)
     * @return true if bit is 1, false if bit is 0
     */
    inline bool getBit(const uint8_t* data, size_t index) {
        return (data[index >> 3] >> (7 - (index & 0x7))) & 1;
    }

    /**
     * Helper to create RMT item
     */
    inline rmt_item32_t make_item(uint32_t duration0_us, uint32_t level0,
                                   uint32_t duration1_us, uint32_t level1) {
        rmt_item32_t item;
        item.duration0 = US_TO_RMT_TICKS(duration0_us);
        item.level0 = level0;
        item.duration1 = US_TO_RMT_TICKS(duration1_us);
        item.level1 = level1;
        return item;
    }

public:
    BinRAWProtocol() : te(BINRAW_TE_DEFAULT), total_bits(0) {}

    const char* getName() const override {
        return "BinRAW";
    }

    /**
     * BinRAW does not support RX decoding (it's a playback-only format)
     * Use RAW protocol for capturing unknown signals
     */
    bool decode(const rmt_item32_t* data, size_t len, ProtocolDecodeResult& result) override;

    /**
     * Encode BinRAW data for transmission
     * Note: BinRAW doesn't use ProtocolEncodeParams directly
     * Data must be loaded via deserializeFromFile() first
     */
    bool encode(const ProtocolEncodeParams& params) override;

    bool getEncodedData(const rmt_item32_t** out_data, size_t* out_len) override;

    /**
     * BinRAW serialization not supported (use RAW protocol for capture)
     * BinRAW files are generated by Flipper Zero from RAW captures
     */
    bool serializeToFile(File& file, const ProtocolDecodeResult& result) override;

    /**
     * Deserialize BinRAW data from .sub file
     * Reads Bit, TE, and multiple Bit_RAW/Data_RAW blocks
     */
    bool deserializeFromFile(File& file, ProtocolEncodeParams& params) override;

    // BinRAW doesn't support state machine decoding (playback only)
    void feed(bool level, uint32_t duration) override {}
    void reset() override {}
    bool decode_check(ProtocolDecodeResult& result) override { return false; }

    size_t getMinimumLength() const override {
        return 0;  // Not used for RX
    }

    const uint32_t* getCommonFrequencies() const override {
        // BinRAW can be used with any frequency (protocol-agnostic)
        static const uint32_t freqs[] = {
            315000000,   // 315 MHz (North America)
            433920000,   // 433.92 MHz (Europe/Asia)
            868000000,   // 868 MHz (Europe)
            390000000,   // 390 MHz (Security+ alternate)
            0
        };
        return freqs;
    }

    /**
     * Get total duration of the signal in microseconds
     * Useful for UI display and timing calculations
     */
    uint32_t getTotalDuration() const {
        return total_bits * te;
    }

    /**
     * Get number of Data_RAW blocks loaded
     */
    size_t getBlockCount() const {
        return blocks.size();
    }
};

#endif // __PROTOCOL_BINRAW_H__
